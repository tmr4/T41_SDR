#include "SDT.h"
#include "Button.h"
#include "Display.h"
#include "Encoders.h"
#include "InfoBox.h"
#include "Menu.h"
#include "Tune.h"
#include "Utility.h"

//-------------------------------------------------------------------------------------------------------------
// Data
//-------------------------------------------------------------------------------------------------------------

int32_t IFFreq = SampleRate / 4;  // IF (intermediate) frequency
long TxRxFreq;
unsigned long long Clk1SetFreq = 1000000000ULL;

//-------------------------------------------------------------------------------------------------------------
// Forwards
//-------------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------------------
// Code
//-------------------------------------------------------------------------------------------------------------

/*****
  Purpose: A special variant of SetFreq() used only for calibration.

  Parameter list:
    void

  Return value;
    void

  CAUTION: SI5351_FREQ_MULT is set in the si5253.h header file and is 100UL
*****/
void SetFreqCal(void) {
  unsigned long long Clk2SetFreq;

  // NEVER USE AUDIONOINTERRUPTS HERE: that introduces annoying clicking noise with every frequency change
  // SI5351_FREQ_MULT is 100ULL, MASTER_CLK_MULT is 4;

  // The SSB LO frequency is always the same as the displayed transmit frequency.
  // The CW LOT frequency must be shifted by 750 Hz due to the way the CW carrier is generated by a quadrature tone.
  if (bands[currentBand].mode == DEMOD_LSB)
    Clk1SetFreq = (((TxRxFreq + CWFreqShift + calFreqShift) * SI5351_FREQ_MULT)) * MASTER_CLK_MULT;  // flip CWFreqShift, sign originally minus
  if (bands[currentBand].mode == DEMOD_USB)
    Clk1SetFreq = (((TxRxFreq - CWFreqShift - calFreqShift) * SI5351_FREQ_MULT)) * MASTER_CLK_MULT;  // flip CWFreqShift, sign originally plus

  //  The receive LO frequency is not dependent on mode or sideband.  CW frequency shift is done in DSP code.
  Clk2SetFreq = ((centerFreq * SI5351_FREQ_MULT) + IFFreq * SI5351_FREQ_MULT) * MASTER_CLK_MULT;

  //  Set and enable both RX and TX local oscillator outputs.
  si5351.set_freq(Clk2SetFreq, SI5351_CLK2);
  si5351.set_freq(Clk1SetFreq, SI5351_CLK1);
  si5351.output_enable(SI5351_CLK2, 1);
  si5351.output_enable(SI5351_CLK1, 1);

}

/*****
  Purpose: Set center tuning frequency
           NCOFreq is unchanged

  Parameter list:
    void

  Return value;
    void
*****/
void SetTxRxFreq(long freq) {
  TxRxFreq = freq;

  SetFreq();

  ShowFrequency();          // update frequency display
  ShowOperatingStats();     // update center frequency in band info
  ShowSpectrumFreqValues(); // update spectrum frequency values
}

/*****
  Purpose: Reset tuning to center
           NCOFreq is set to zero

  Parameter list:
  void

  Return value;
  void
*****/
void ResetTuning() {
  centerFreq += NCOFreq;
  NCOFreq = 0L;

  SetTxRxFreq(centerFreq);

  DrawBandwidthBar();
}

/*****
  Purpose: Adjust center tuning frequency
           NCOFreq is unchanged

  Parameter list:
    long tuneChange - amound to change center freq

  Return value;
    void
*****/
void SetCenterTune(long tuneChange) {
  centerFreq += tuneChange;  // tune the master vfo

  SetTxRxFreq(centerFreq + NCOFreq);
}

/*****
  Purpose: Set NCO frequency

  Parameter list:
    void

  Return value;
    void
*****/
void SetNCOFreq(long newNCOFreq) {
  NCOFreq = newNCOFreq;
  fineTuneFlag = true;
  if (activeVFO == VFO_A) {
    currentFreqA = centerFreq + NCOFreq;
  } else {
    currentFreqB = centerFreq + NCOFreq;
  }
  // ===============  Recentering at band edges ==========
  if (spectrumZoom != 0) {
    if((NCOFreq + bands[currentBand].FHiCut) >= (96000 / (1 << spectrumZoom))) {
      NCOFreq += bands[currentBand].FHiCut;
      fineTuneFlag = false;
      resetTuningFlag = true;
      return;
    }
    if((NCOFreq + bands[currentBand].FLoCut) <= (-96000 / (1 << spectrumZoom))) {
      NCOFreq += bands[currentBand].FLoCut;
      fineTuneFlag = false;
      resetTuningFlag = true;
      return;
    }
  } else {
    if (NCOFreq > 142000 || NCOFreq < -43000) {  // Offset tuning window in zoom 1x
      fineTuneFlag = false;
      resetTuningFlag = true;
      return;
    }
  }

  TxRxFreq = centerFreq + NCOFreq;
}

/*****
  Purpose: Set fine tuning frequency

  Parameter list:
    void

  Return value;
    void
*****/
void SetFineTune(long tuneChange) {
  SetNCOFreq(NCOFreq + tuneChange);
}

/*****
  Purpose: Set si5351 frequency

  Parameter list:
    void

  Return value;
    void

  CAUTION: SI5351_FREQ_MULT is set in the si5253.h header file and is 100UL
*****/
void SetFreq() {
  unsigned long long Clk2SetFreq;

  // NEVER USE AUDIONOINTERRUPTS HERE: that introduces annoying clicking noise with every frequency change
  // SI5351_FREQ_MULT is 100ULL, MASTER_CLK_MULT is 4;

  // The SSB LO frequency is always the same as the displayed transmit frequency.
  // The CW LOT frequency must be shifted by 750 Hz due to the way the CW carrier is generated by a quadrature tone.
  if (radioState == SSB_TRANSMIT_STATE) {
    Clk1SetFreq = (TxRxFreq * SI5351_FREQ_MULT) * MASTER_CLK_MULT;
  } else {
    if (radioState == CW_TRANSMIT_STRAIGHT_STATE || radioState == CW_TRANSMIT_KEYER_STATE) {
      if (bands[currentBand].mode == DEMOD_LSB) {
        Clk1SetFreq = (((TxRxFreq + CWFreqShift + calFreqShift) * SI5351_FREQ_MULT)) * MASTER_CLK_MULT;  // flip CWFreqShift, sign originally minus
      } else {
        if (bands[currentBand].mode == DEMOD_USB) {
          Clk1SetFreq = (((TxRxFreq - CWFreqShift - calFreqShift) * SI5351_FREQ_MULT)) * MASTER_CLK_MULT;  //  flip CWFreqShift, sign originally plus
        }
      }
    }
  }

  //  The receive LO frequency is not dependent on mode or sideband.  CW frequency shift is done in DSP code.
  Clk2SetFreq = ((centerFreq * SI5351_FREQ_MULT) + IFFreq * SI5351_FREQ_MULT) * MASTER_CLK_MULT;

  if (radioState == SSB_RECEIVE_STATE || radioState == CW_RECEIVE_STATE) {   //  Receive state
    si5351.set_freq(Clk2SetFreq, SI5351_CLK2);
    si5351.output_enable(SI5351_CLK1, 0);  // CLK1 (transmit) off during receive to prevent birdies
    si5351.output_enable(SI5351_CLK2, 1);
  }

  if (radioState == SSB_TRANSMIT_STATE || radioState == CW_TRANSMIT_STRAIGHT_STATE || radioState == CW_TRANSMIT_KEYER_STATE) {  // Transmit state
    si5351.set_freq(Clk1SetFreq, SI5351_CLK1);
    si5351.output_enable(SI5351_CLK2, 0);  // CLK2 (receive) off during transmit to prevent spurious outputs
    si5351.output_enable(SI5351_CLK1, 1);
  }
}

/*****
  Purpose: Set VFO A to receive frequency and VFO B to the transmit frequency

  Parameter list:
    void

  Return value;
    void

  CAUTION: SI5351_FREQ_MULT is set in the si5253.h header file and is 100UL
*****/
void DoSplitVFO() {
  int centerTxt;
  int val;
  long chunk = SPLIT_INCREMENT;
  long splitOffset;

  // Clear info box
  tft.fillRect(INFO_BOX_L + 2, INFO_BOX_T + 2, INFO_BOX_W - 4, INFO_BOX_H - 4, RA8875_BLACK);

  // set up info box to retrieve xmit offset
  tft.drawRect(INFO_BOX_L, INFO_BOX_T, INFO_BOX_W, INFO_BOX_H, RA8875_MAGENTA);
  tft.setFontScale( (enum RA8875tsize) 1);
  centerTxt = (INFO_BOX_W - strlen("xmit offset:") * tft.getFontWidth()) / 2 + INFO_BOX_L;
  tft.setCursor(centerTxt, INFO_BOX_T + 10);
  tft.print("xmit offset:");

  // Set starting offset to 500Hz
  splitOffset = chunk;
  tft.setTextColor(RA8875_GREEN);
  tft.setCursor(centerTxt, INFO_BOX_T + 90);
  tft.print(splitOffset);
  tft.print(" Hz  ");

  // get offset
  while (true) {
    if (menuEncoderMove != 0) {                     // Changed encoder?
      splitOffset += menuEncoderMove * chunk;
      tft.fillRect(centerTxt, INFO_BOX_T + 90, 150, 50, RA8875_BLACK);
      tft.setCursor(centerTxt, INFO_BOX_T + 90);
      tft.print(splitOffset);
      tft.print(" Hz  ");
    }
    menuEncoderMove = 0L;

    val = ReadSelectedPushButton();                                  // Read pin that controls all switches
    val = ProcessButtonPress(val);
    delay(150L);
    if (val == MENU_OPTION_SELECT) { // Make a choice??
      Clk1SetFreq += splitOffset;    // New transmit frequency
      //UpdateInfoBox();
      menuEncoderMove = 0L;
      break;
    }
  }

  currentFreqB = currentFreqA + splitOffset;
  // *** note that the change in FREQUENCY_Y from 45 to 28 was not reflected here ***
  //FormatFrequency(currentFreqB, freqBuffer);
  //tft.fillRect(FREQUENCY_X_SPLIT, FREQUENCY_Y - 12, VFOB_PIXEL_LENGTH, FREQUENCY_PIXEL_HI, RA8875_BLACK);
  ////tft.setCursor(FREQUENCY_X_SPLIT, FREQUENCY_Y);
  ////tft.setFont(&FreeMonoBold24pt7b);
  //tft.setTextColor(RA8875_GREEN);
  //tft.setFontScale(3, 2);
  //tft.setCursor(0, FREQUENCY_Y);
  //tft.print(freqBuffer);                                          // Show VFO_A
  //
  ////tft.setFont(&FreeMonoBold18pt7b);
  //FormatFrequency(currentFreqA, freqBuffer);
  //tft.setTextColor(RA8875_LIGHT_GREY);
  ////tft.setCursor(FREQUENCY_X, FREQUENCY_Y + 6);
  //tft.setFontScale(1, 2);
  //tft.setCursor(FREQUENCY_X_SPLIT + 60, FREQUENCY_Y - 15);
  //tft.print(freqBuffer);                                          // Show VFO_A

  //tft.useLayers(1);                 //mainly used to turn on layers!
  //tft.layerEffect(OR);
  //tft.writeTo(L2);
  //tft.clearMemory();
  //tft.writeTo(L1);

  //tft.setFont(&FreeMono9pt7b);
  //tft.setTextColor(RA8875_RED);
  //tft.setCursor(FILTER_PARAMETERS_X + 180, FILTER_PARAMETERS_Y + 6);
  //tft.print("Split Active");

  //tft.setFontDefault();
}
